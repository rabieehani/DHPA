;## WHAT IS IT?
;
;The Directed Homophilic Preferential Attachment (DHPA) model is based on the simple preferential attachment, which can model the dynamics of opinions and directed connections of social network users by considering the homophily between them and two social phenomena, the spiral of silence and echo chambers, and show the forms of consensus or polarity in public opinion.
;
;## HOW IT WORKS
;
;Based on the probability, one of the following four scenarios is chosen at each time step: 1) adding a new user to the network and following another user, 2) adding a new user to the network and being followed by another user, 3) following a user in the network by another user and 4) unfollowing a user by another user. To choose which user to follow or unfollow, various characteristics such as in-degree, homophily, following back, the state of opinion expressed and the level of confidence in the correctness of the attitude are considered.
;In the domain of opinion dynamics, each user chooses whether or not to express an opinion based on his tendency for self-censor and his confidence in the correctness of his attitude. On the other hand, he updates his confidence based on his prior level of confidence and the opinion climate he observes in his neighbors.
;It should be mentioned that attitudes have been observed along a spectrum, allowing homophily to be quantified about attitudes.
;With these interpretations, our model may design or rewire the network so that any user may express their opinion at every time step. The network that was constructed has some characteristics of actual social networks, where public opinion can reach a consensus or become polarized in case of confrontation between users.
;
;## HOW TO USE IT
;
;Press SETUP to initialize model variables based on given inputs
;Press GO to have the model run continuously.
;Press GO-ONCE to have the model run once.
;Enter the desired values in each entry.
;
;## RELATED MODELS
;
;Preferential Attachment model
;
;## Model authors
;
;Hani Rabiee (rabiee.hani@gmail.com)
;Behrouz Tork Ladani
;Ebrahim Sahafizadeh
;
;## Article
;
;"A Social Network Model for Analysis of Public Opinion Formation Process" (that is being published).



extensions [nw]

breed [users user]

;global variables
globals
[
  new-node-attitude-valence
  number-of-normal-users
  number-of-noisy-users
  number-of-positive-noisy-users
  number-of-negative-noisy-users
  num-of-all-follow
  num-of-normal-user-follow
  num-of-noisy-user-follow
  num-of-all-unfollow
  num-of-silents
  num-of-positive-express
  num-of-negative-express
  clustering-coefficient
  mean-clustering-coefficient
  society-pressure
  society-pressure-after-crisis
  central-users
  unsimilarity-criterion
  noisy-user-rate
  date-time
  state
  file-name
  node-file-name
  edge-file-name
  net-file-name

  frame-count
  total-ticks
  frame-interval

  dissagreement-threshold
  middle-passed
  infinity         ; used to represent the distance between two turtles with no path between them
  average-path-length-of-lattice       ; average path length of the initial lattice
  average-path-length                  ; average path length in the current network
]

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; User Own ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
users-own
[	
  ;The attitude-valence level of each user that is in (0,1) range that is the degree of a user in it's opinion that can be seen by others
  ;and the homophily is the difference of two node's strength
  attitude-valence
  ;;The destination/source attractiveness level of each user. They depends on other end of the link
  dst-tendency
  src-tendency
  ;The opinion value of each user that can be "positive/ 1" or "negative/ -1"
  opinion
  ;It shows the willingness of a user to be silent that is in (0,1) range
  willingness-to-self-censor
  willingness-to-self-censor-considering-society-situation
  ;The attitude-confidence level of a user for his opinion that is in (0,1) range
  attitude-confidence
  normalized-attitude-confidence
  ;Contains "Express" or "silent" that is the result of comparition between attitude-confidence and willingness to self censor
  expression-status
  ;The Average of neighbors opinions that they express
  opinion-climate
  ;The degree of similarity to normal-users
  normal-user-likeness
  ;Identifies that a user is a normal-user or noisy-user
  is-noisy-user
  my-state

  distance-from-other-turtles ; list of distances of this node from other turtles
]

links-own [relationship-state]

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Setup Procedures ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
to setup
  clear-all

  set infinity 99999      ; this is an arbitrary choice for a large number
  ; Calculate the initial average path length and clustering coefficient
  set average-path-length find-average-path-length
  set average-path-length-of-lattice average-path-length

  set state "final"
  setup-patches
  if noisy-user-rate-on-each-side?
  [
    set positive-noisy-user-rate noisy-user-rate-on-each-side
    set negative-noisy-user-rate noisy-user-rate-on-each-side
  ]
  ;calculating the number of noisy-users depend on noisy-user rate value that is configured
  set number-of-positive-noisy-users (number-of-users * positive-noisy-user-rate / 100)
  set number-of-negative-noisy-users (number-of-users * negative-noisy-user-rate / 100)

  ;calculating the number of bots and humnas depend on configurations
  set noisy-user-rate (positive-noisy-user-rate + negative-noisy-user-rate)
  set number-of-noisy-users (number-of-users * (noisy-user-rate / 100))
  set number-of-normal-users (number-of-users - number-of-noisy-users)
  set num-of-all-follow 0
  set num-of-normal-user-follow 0
  set num-of-noisy-user-follow 0
  set unsimilarity-criterion 0
  set dissagreement-threshold 0.2

  set date-time (remove "-" remove "." remove ":" remove " " date-and-time)
  set file-name (word "E:/exports/revise/effect of noisy users presence/" date-time "-" state "-dynamic_data.csv")
  set node-file-name (word "E:/exports/revise/effect of noisy users presence/" date-time "-" state "-nodes.csv")
  set edge-file-name (word "E:/exports/revise/effect of noisy users presence/" date-time "-" state "-edges.csv")
  set net-file-name (word "E:/exports/revise/effect of noisy users presence/" date-time "-" state "-net.csv")

  set frame-count 0
  set total-ticks ticks-number
  set frame-interval (total-ticks / 100)

  set middle-passed 0
  calc-society-pressure
  reset-ticks
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Setup Patches ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
to setup-patches
  ask patches [set pcolor white]
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Setup normal-users ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;setup the initial values of normal-users after it creates
to setup-normal-users [agent]
  ask agent
  [
    set my-state "active"

    ;Set defualt color of normal-users for debugging
    set color yellow
    ;Set defualt shepe of normal-users
    set shape "person"
    set is-noisy-user 0
    ifelse willingness-to-self-censor-initial-distribution = "uniform" [set willingness-to-self-censor random-float 1]
    [set willingness-to-self-censor random-normal 0.5 0.5]
    set willingness-to-self-censor-considering-society-situation max list (willingness-to-self-censor - society-pressure) 0
    if crisis-in-middle and (count users > change-state) [crisis-situation-in-middle self]

    set normal-user-likeness 1
    ;calling for set the expression status of this person
    set-expression-status self
    ;set the opinoin value and the attitude-valence value of the person
    let rand random 100
    ifelse rand < positive-opinion-rate
    [
      set opinion 1 ;;"positive"
      ifelse attitude-valence-initial-distribution = "uniform" [set attitude-valence random-float 1]
      [set attitude-valence random-normal 0.5 0.5]

      ifelse attitude-confidence-initial-distribution = "uniform" [set attitude-confidence random-float 100]
      [set attitude-confidence random-normal 50 50]
      set normalized-attitude-confidence sigmoid attitude-confidence
    ]
    [
      set opinion -1 ;;"negative"
      ifelse attitude-valence-initial-distribution = "uniform" [set attitude-valence random-float -1]
      [set attitude-valence random-normal -0.5 0.5]

      ifelse attitude-confidence-initial-distribution = "uniform" [set attitude-confidence random-float 100]
      [set attitude-confidence random-normal 50 50]
      set normalized-attitude-confidence sigmoid attitude-confidence
    ]
    ;set the color of the person
    set-color-user self
    ;set eigenvector-centrality 0
  ]
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Setup noisy-users ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;setup the initial values of noisy-users after it creates
to setup-noisy-users [agent]
  ask agent
  [
    set my-state "active"

    ;Set defualt shepe of noisy-users
    set shape "circle"
    set is-noisy-user 1
    set normalized-attitude-confidence 1
    set willingness-to-self-censor 0
    set willingness-to-self-censor-considering-society-situation 0
    set expression-status 1
    ;noisy-user-smartness is standard deviation of noisy-user normal-user-likeliness
    set normal-user-likeness noisy-user-smartness
    ;set the opinoin value and the attitude-valence value of the noisy-user
    let rand random (positive-noisy-user-rate + negative-noisy-user-rate)
    ifelse rand < positive-noisy-user-rate
    [
      set opinion 1 ;;"positive"
      set attitude-valence attitude-of-positive-bots
    ]
    [
      set opinion -1 ;;"negative"
      set attitude-valence attitude-of-positive-bots
    ]
		;set the color of the noisy-user
    set-color-user self
    ;set eigenvector-centrality 0
  ]
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; calculating society pressure ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
to calc-society-pressure
  ifelse society-situation = "normal" [set society-pressure 0]
  [
    ifelse society-situation = "semi-critical" [set society-pressure 0.3]
    [set society-pressure 0.6]
  ]
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; calculating society pressure after crisis ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
to calc-society-pressure-after-crisis
 ifelse situation-after-crisis = "semi-crisis" [set society-pressure-after-crisis 0.3]
 [set society-pressure-after-crisis 0.6]
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; calculating expression status of agents ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;set the expression status of all of input agents
to set-expression-status [agents]
  ask agents
  [
    ifelse normalized-attitude-confidence > willingness-to-self-censor-considering-society-situation
    [
      set expression-status 1
    ]
    [
      set expression-status 0
    ]
    set-color-user self
  ]
  set num-of-silents count turtles with [expression-status = 0]
  set num-of-positive-express count turtles with [opinion = 1 and expression-status = 1]
  set num-of-negative-express count turtles with [opinion = -1 and expression-status = 1]
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; setting color of an agent ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;set the color of the person depends on it is noisy-user or normal-user, it's opinion and it's expression status
to set-color-user [agent]
  ask agent
  [
    ifelse is-noisy-user = 0
    [
      ifelse opinion = 1
      [
        ;set blue, if it is normal-user, has positive opinion and expressing it's opinion
        ;set light blue, if it is normal-user, has positive opinion and be silent
        ifelse expression-status = 1 [set color blue]
        [set color blue + 4]
      ]
      [
        ;set red, if it is normal-user, has negative opinion and expressing it's opinion
        ;set light red, if it is normal-user, has negative opinion and be silent
        ifelse expression-status = 1 [set color red]
        [set color red + 4]
      ]
    ]
    [
      ifelse opinion = 1
      [
        ;set dark blue, if it is noisy-user and has positive opinion
        set color blue - 1
      ]
      [
        ;set dark red, if it is noisy-user and has negative opinion
        set color red - 1
      ]
    ]
  ]
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; setting color of an edge ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;set the color of the person depends on it is noisy-user or normal-user, it's opinion and it's expression status
to set-color-relation [edge]
  ask edge
  [
    ifelse all? both-ends [opinion = 1]
    [set color blue + 3]
    [
      ifelse all? both-ends [opinion = -1]
      [set color red + 3]
      [set color magenta + 3]
    ]
  ]
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Go Procedure ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
to go

  ;The main procedure continues until ticks number that analyzer configured.
  if ticks >= ticks-number
  [
    if clustering-coefficient?
    [
      set clustering-coefficient global-clustering-coefficient
      set mean-clustering-coefficient mean [ nw:clustering-coefficient ] of users
    ]
    if export-world? [export-worlds]
    stop
  ]

  ;The avg-degree-distribution is the maximum of overall average degree distribution and
  ;the maximum links that can be create is less than avg-degree-distribution * number-of-users
  if count links < (max-avg-degree-distribution * number-of-users)
  [
    if change-state? and (count users = change-state) and (middle-passed = 0)
    [
      set state "middle"
      ;user-message (word "export in middle")
      export
      set middle-passed 1

      if encourage-to-leave? [encourage-to-leave]

      if crisis-in-middle
      [
        calc-society-pressure-after-crisis
        crisis-creation
      ]

      if awareness? [awareness-in-middle]

      set state "final"
    ]
    if change-state? and awareness? and (count users > change-state) and awareness-counter > 0
    [
     awareness-in-middle
    ]

    if opinion-dynamics? [opinion-dynamics]

    ;call the Attachment model and meke the network
    generating-network
  ]
  ;call the layout procedure which shows the appropriate appearance of the model
  if layout? [ layout ]
  resize-users

  if path-length? [set average-path-length find-average-path-length]
  if export-dynamic-data? [export-dynamic-data]

  if export-frames-csv? and (ticks mod frame-interval = 0) [
    export-frames-csv
  ]

  if export-frames-gexf? and (ticks mod frame-interval = 0) [
  export-frames-gexf

    set frame-count frame-count + 1
  ]

  tick
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; awareness-in-middle ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
to awareness-in-middle
  ask users with [is-noisy-user = 0]
  [
    let diff-from-target-of-awareness abs(attitude-valence - target-of-awareness)
    set attitude-confidence max list (attitude-confidence + (range-of-awareness / 2 - diff-from-target-of-awareness)) 0
    set normalized-attitude-confidence sigmoid attitude-confidence
    set awareness-counter (awareness-counter - 1)
  ]
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;Opinion-Dynamics;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
to opinion-dynamics
  calc-opinion-climate
  ;calc-polarity-criterion
  calc-normalized-attitude-confidence
  set-expression-status users
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;encourage-to-leave;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
to encourage-to-leave
  if encourage-to-leave?
  [
    ask n-of (encouraged-positive-users / 100 * (count users with [opinion = 1])) (users with [opinion = 1])
    [
      set willingness-to-self-censor 1
      set willingness-to-self-censor-considering-society-situation 1
    ]
  ]
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;crisis-creation;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
to crisis-creation
  ask users with [is-noisy-user = 0] [set willingness-to-self-censor-considering-society-situation max list (willingness-to-self-censor - society-pressure-after-crisis) 0]
end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;crisis-situation-in-middle;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
to crisis-situation-in-middle [agent]
  ask agent [set willingness-to-self-censor-considering-society-situation max list (willingness-to-self-censor - society-pressure-after-crisis) 0]
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;Network-Generating-&-Rewiring;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;Depends on the values "add-src-node-rate" and "add-src-node" it decides that add source/destination node or add edge
to generating-network
  let rand random (add-follower-prob + add-followee-prob + follow-prob + unfollow-prob)
  if rand <  add-follower-prob
  [
    add-src-node
  ]
  if (rand >=  add-follower-prob) and (rand < (add-follower-prob + add-followee-prob))
  [
    add-dst-node
  ]
  if (rand >= (add-follower-prob + add-followee-prob)) and (rand < (add-follower-prob + add-followee-prob + follow-prob)) and count users >= 2
  [
    ifelse count users with [is-noisy-user = 1] = 0 [add-follow users]
    [
      let rand2 random (bot-follow-coefficient + 1)
      ifelse rand2 < bot-follow-coefficient
      [add-follow users with [is-noisy-user = 1]]
      [add-follow users with [is-noisy-user = 0]]
    ]
  ]
  if (rand >=  add-follower-prob + add-followee-prob + follow-prob) and count users >= 2
  [
    unfollow users with [is-noisy-user = 0]
  ]
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;Scenario 1 : Add a node as a follower user;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; used for creating a new node with source role
to add-src-node
  ;If there is at least an user exists
  ifelse not any? users
  ;If there is no user and the user is the first one, create the first user
  [
    create-users 1 [setup-normal-users self]
    set num-of-normal-user-follow (num-of-normal-user-follow + 1)
  ]
  [
    ifelse add-noisy-users-at-last?
    [
      ;Before all normal-users does not added, no noisy-user should be add
      if (count users < number-of-normal-users)
      [
        ;set agent-type "normal-user"
        add-source "normal-user"
      ]
      if (count users >= number-of-normal-users) and (count users < number-of-users)
      [
        ;If all the normal-users added, it adds the noisy-users
        ;set agent-type "noisy-user"
        add-source "noisy-user"
      ]
    ]

    [
      if count users < number-of-users
      [
        let rand2 random 100
        ifelse rand2 < noisy-user-rate
        [add-source "noisy-user"]
        [add-source "normal-user"]
      ]
    ]
  ]
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
to add-source [agent-type]
  let source-node user 0
  let agent-set users
  let m x

  create-users 1
	[
    set source-node self

    ifelse agent-type = "normal-user" [setup-normal-users self]
    [setup-noisy-users self]
    set agent-set other users
  ]
  if count users - 1 < m [set m (count users - 1)]
  repeat m
  [
    ;Find an appropriate and attractive destinatin node for the source node
    let destination-partner dst-partner source-node agent-set
    ask source-node
    [
      if any? other users
      [
        ;crate a link between the source and destination node
        create-link-to destination-partner [
          set-color-relation self
          set relationship-state "connected"
        ]
        set num-of-all-follow (num-of-all-follow + 1)
        ifelse agent-type = "normal-user" [set num-of-normal-user-follow (num-of-normal-user-follow + 1)]
        [set num-of-noisy-user-follow (num-of-noisy-user-follow + 1)]

        ask destination-partner [set agent-set other agent-set]
        ;;position the new node near its partner
        move-to destination-partner
        fd 8
      ]
    ]
  ]
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;Scenario 2 : Add a node as a followee user;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; used for creating a new node with destination role
to add-dst-node

  ;If there is at least an user exists
  ifelse not any? users
  ;If there is no user and the user is the first one, create the first user
  [
    create-users 1 [setup-normal-users self]
    set num-of-normal-user-follow (num-of-normal-user-follow + 1)
  ]
  [
    ifelse add-noisy-users-at-last?
    [
      ;Before all normal-users does not added, no noisy-user should be add
      if (count users < number-of-normal-users)
      [
        ;set agent-type "normal-user"
        add-dest "normal-user"
      ]
      if (count users >= number-of-normal-users) and (count users < number-of-users)
      [
        ;If all the normal-users added, it adds the noisy-users
        ;set agent-type "noisy-user"
        add-dest "noisy-user"
      ]
    ]

    [
      if count users < number-of-users
      [
        let rand2 random 100
        ifelse rand2 < noisy-user-rate
        [add-dest "noisy-user"]
        [add-dest "normal-user"]
      ]
    ]
  ]
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
to add-dest [agent-type]
  let dest-node user 0
  let agent-set users
  let m x

  create-users 1
	[
    set dest-node self

    ifelse agent-type = "normal-user" [setup-normal-users self]
    [setup-noisy-users self]
      ;set new-node-attitude-valence attitude-valence
    set agent-set other users
  ]
  ;set num-of-added-followee (num-of-added-followee + 1)
  if count users - 1 < m [set m (count users - 1)]
  repeat m
  [
    ;Find an appropriate and attractive destinatin node for the source node
    let source-partner src-partner dest-node agent-set
    ask dest-node
    [
      if any? other users
      [
        ;crate a link between the source and destination node
        create-link-from source-partner [
          set-color-relation self
          set relationship-state "connected"
        ]
        set num-of-all-follow (num-of-all-follow + 1)
        ifelse agent-type = "normal-user" [set num-of-normal-user-follow (num-of-normal-user-follow + 1)]
        [set num-of-noisy-user-follow (num-of-noisy-user-follow + 1)]

        ask source-partner [set agent-set other agent-set]
        ;;position the new node near its partner
        move-to source-partner
        fd 8
      ]
    ]
  ]
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;Scenario 3 : Add an edge between two existing users;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; used for creating a new edge between two nodes considering their source/destination attractiveness
to add-follow [agents]
  let tendency 0
  let sum-of-tendency 0
  let temp 0
  let follower one-of users
  let followee one-of users

  let follow-tendency-list []

  ask agents
  [
    set follower self
    let followees-of-follower (user 0)
    ask follower [set followees-of-follower out-link-neighbors]
    let agent-set other users with [not member? self followees-of-follower]
    ask agent-set
    [
      set followee self
      set tendency calc-follow-tendency follower followee
      set follow-tendency-list lput (list follower followee tendency) follow-tendency-list
      set sum-of-tendency (sum-of-tendency + tendency)
    ]
  ]
  let rnd random-float sum-of-tendency
  set sum-of-tendency 0

  if length follow-tendency-list != 0
  [
    let counter 0
    while [rnd > (sum-of-tendency + (item 2 (item counter follow-tendency-list)))]
    [
      set sum-of-tendency (sum-of-tendency + (item 2 (item counter follow-tendency-list)))
      set counter (counter + 1)
    ]
    set follower (item 0 (item counter follow-tendency-list))
    set followee (item 1 (item counter follow-tendency-list))
    ask follower
    [
      create-link-to followee [
        set-color-relation self
        set relationship-state "connected"
      ]
      set num-of-all-follow (num-of-all-follow + 1)
      ifelse is-noisy-user = 0
      [set num-of-normal-user-follow (num-of-normal-user-follow + 1)]
      [set num-of-noisy-user-follow (num-of-noisy-user-follow + 1)]
    ]
  ]
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;Scenario 4 : remove an edge between two users;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; used for creating a new edge between two nodes considering their source/destination attractiveness
to unfollow [agents]
  let tendency 0
  let sum-of-tendency 0
  let temp 0
  let follower one-of users
  let followee one-of users
  let finished? false

  let unfollow-tendency-list []

  ask agents with [count out-link-neighbors > 1]
  [
    set follower self
    let agent-set out-link-neighbors
    ask agent-set
    [
      set followee self
      set tendency calc-unfollow-tendency follower followee
      set unfollow-tendency-list lput  (list follower followee tendency) unfollow-tendency-list

      set sum-of-tendency (sum-of-tendency + tendency)
    ]
  ]
  let rnd random-float sum-of-tendency

  set sum-of-tendency 0

  if length unfollow-tendency-list != 0
  [
    let i 0
    while [rnd > (sum-of-tendency + (item 2 (item i unfollow-tendency-list)))]
    [
      set sum-of-tendency (sum-of-tendency + (item 2 (item i unfollow-tendency-list)))
      set i (i + 1)
    ]
    set follower (item 0 (item i unfollow-tendency-list))
    set followee (item 1 (item i unfollow-tendency-list))
    ask follower
    [
      ask out-link-to followee [
        set relationship-state "disconnected"
        die
      ]
      set num-of-all-unfollow (num-of-all-unfollow + 1)
    ]
  ]
end

to-report calc-source-tendency [follower followee]
  let homophily calc-homophily follower followee
  report homophily
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;Calculating tendency to follow another user;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
to-report calc-follow-tendency [follower followee]
  let normalized-followee-in-degree 0
  let in-degree 0
  let followee-expression-status 0
  let following-score 0
  set following-score calc-following-score follower followee
  ask followee
  [
    set in-degree count in-link-neighbors + in-degree-constant

    set followee-expression-status expression-status
  ]
  let homophily calc-homophily follower followee

  ifelse bot-attachment-type = "DHPA"
  [report in-degree * homophily  * following-score * followee-expression-status]
  [ifelse bot-attachment-type = "PA"
    [report in-degree]
    [ifelse bot-attachment-type = "IPA"
      [report (count links) - in-degree]
      [ifelse bot-attachment-type = "random"
        [report 1]
        [ifelse bot-attachment-type = "Influencers"
          [report nw:eigenvector-centrality]
          ;ifelse bot-attachment-type = "Influencers + DHPA"
          [report nw:eigenvector-centrality * in-degree * homophily  * following-score * followee-expression-status]
        ]
      ]
    ]
  ]
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;Calculating tendency to unfollow another user;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
to-report calc-unfollow-tendency [follower followee]
  let follower-attitude-confidence 0
  let normalized-followee-in-degree 0
  let followee-expression-status 0
  let unfollowing-score 0
  let follower-extrimism-value 0
  let followee-in-degree 0
  set unfollowing-score calc-unfollowing-score follower followee
  ask follower
  [
    set follower-attitude-confidence normalized-attitude-confidence
  ]
  ask followee
  [
    set followee-in-degree (count in-link-neighbors + in-degree-constant)
    set followee-expression-status expression-status
  ]
  let heterophily calc-heterophily follower followee
  ifelse followee-in-degree != 0
  [
    report follower-attitude-confidence * followee-expression-status * unfollowing-score * heterophily / followee-in-degree
  ]
  [report 0]
end


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;Calculating Heterophily between two users;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
to-report calc-heterophily [first-agent second-agent]
  let first-agent-attitude-valence 0
  let second-agent-attitude-valence 0
  ask first-agent [set first-agent-attitude-valence attitude-valence]
  ask second-agent [set second-agent-attitude-valence attitude-valence]
  let heterophily abs(first-agent-attitude-valence - second-agent-attitude-valence)
  report heterophily
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;Calculating Homophily between two users;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
to-report calc-homophily [first-agent second-agent]
  let heterophily calc-heterophily first-agent second-agent
  report (2 - heterophily)
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;Find an appropriate and attractive source node for the input agent set;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
to-report dst-partner [follower agents]
  ;set a random number between zero and calculated sum-of-dst-tendency
  ;for m edge adding:
  let followees-of-follower (user 0)
  ask follower
  [
    set followees-of-follower out-link-neighbors
    set agents other agents with [not member? self followees-of-follower]
  ]

  let rnd random-float sum-of-dst-tendency follower agents
  let temp 0

  let destination one-of agents
  let finished? false
  ask agents
  [
    if finished? = false
    [
      ;choose a destination node considering the probaility distribution of all users destination attractiveness
      set temp (temp + dst-tendency)
      if rnd <= temp
      [
        set destination self
        set finished? true
      ]
    ]
  ]
  report destination
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;Find an appropriate and attractive destination node for the input agent set;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
to-report src-partner [followee agents]
  ;for m edge adding:
  let followers-of-followee (user 0)
  ask followee
  [
    set followers-of-followee in-link-neighbors
    set agents other agents with [not member? self followers-of-followee]
  ]
  ;set a random number between zero and calculated sum-of-src-tendency
  let followee-expression-status 0
  ask followee [set followee-expression-status expression-status]
  ifelse followee-expression-status = 0 [report one-of agents]
  [
    let rnd random-float sum-of-src-tendency followee agents
    let temp 0
    let source one-of agents
    let finished? false
    ask agents
    [
      if finished? = false
      [
        ;choose a source node considering the probaility distribution of all users source attractiveness
        set temp (temp + src-tendency)
        if rnd <= temp
        [
          set source self
          set finished? true
        ]
      ]
    ]
    report source
  ]
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;Calculate the destination attractivenes of all nodes depend on their in-degree and
;source node attitude-valence and calculate sum of them;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
to-report sum-of-dst-tendency [source-node agents]
  let summation 0
  ask agents
  [
    set dst-tendency calc-follow-tendency source-node self
    set summation (summation + dst-tendency)
  ]
  report summation
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;Calculate the source attractivenes of all nodes depend on their out-degree and
;destination node attitude-valence and calculate sum of them;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
to-report sum-of-src-tendency [destination-node agents]
  let summation 0
  let followee-expression-status 0
  ask destination-node [set followee-expression-status expression-status]
  ifelse followee-expression-status = 0 [report 0]
  [
    ask agents
    [
      set src-tendency calc-source-tendency destination-node self

      set summation (summation + src-tendency)
    ]
    report summation
  ]
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;Calculating Opinion Climate from a user viewpoint;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
to calc-opinion-climate
  let neighbors-opinion 0
;  let sum-of-opinion-cliamte 0
  set unsimilarity-criterion 0
  let sum-of-unsimilarity 0
  let unsimilarity 0
  ask users
  [
    ifelse count (out-link-neighbors with [expression-status = 1]) > 0
    [
      set neighbors-opinion 0
      ask out-link-neighbors with [expression-status = 1]
      [
        set neighbors-opinion (neighbors-opinion + (attitude-valence * normal-user-likeness))
      ]
      set opinion-climate (neighbors-opinion / (count (out-link-neighbors with [expression-status = 1])))
    ]
    [
      set opinion-climate 0
    ]
  ]
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;Normalizing attitude confidence with Sigmoid function;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
to calc-normalized-attitude-confidence
  ask users with [is-noisy-user = 0]
  [
    if count (out-link-neighbors with [expression-status = 1]) > 0
    [
      let opinion-dissagreement abs (attitude-valence - opinion-climate)
      set attitude-confidence max list (attitude-confidence + (dissagreement-threshold - opinion-dissagreement)) 0
      set normalized-attitude-confidence sigmoid attitude-confidence
    ]
  ]
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;Sigmoid function;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
to-report sigmoid [ param ]
  report 2 * (1 / (1 + e ^ (sigmoid-slope * (- param)))) - 1
end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;Calculating score of follow-back;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
to-report calc-following-score [follower followee]
  let score 0
  ask follower
  [
  	ifelse out-link-neighbor? followee [set score 0]
    [
      ifelse in-link-neighbor? followee [set score 2]
      [set score 1]
    ]
  ]
  report score
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;Calculating score of unfollow-back;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
to-report calc-unfollowing-score [follower followee]
  let score 0
  ask follower
  [
  	ifelse out-link-neighbor? followee
    [
      ifelse in-link-neighbor? followee [set score 1]
      [set score 2]

    ]
    [
      set score 0
    ]
  ]
  report score
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;
;;; Layout ;;;
;;;;;;;;;;;;;;

;; resize-nodes, change back and forth from size based on degree to a size of 1
to resize-users
  ifelse not resize-users? [ ask users [ set size 1 ] ]
  [ask users [ set size sqrt max (list (count in-link-neighbors) 1)]]
end


to layout
  ifelse layout-chooser = "normal"
  [
    ;; the number 3 here is arbitrary; more repetitions slows down the
    ;; model, but too few gives poor layouts
    repeat 3 [
      ;; the more users we have to fit into the same amount of space,
      ;; the smaller the inputs to layout-spring we'll need to use
      let factor sqrt count users
      ;; numbers here are arbitrarily chosen for pleasing appearance
      if factor != 0
      [
        layout-spring users links (1 / factor) (7 / factor) (2 / factor)
        display  ;; for smooth animation
      ]
    ]
    ;; don't bump the edges of the world
    let x-offset max [xcor] of users + min [xcor] of users
    let y-offset max [ycor] of users + min [ycor] of users
    ;; big jumps look funny, so only adjust a little each time
    set x-offset limit-magnitude x-offset 0.1
    set y-offset limit-magnitude y-offset 0.1
    ask users [ setxy (xcor - x-offset / 2) (ycor - y-offset / 2) ]
  ]
  ;Fruchterman-Reingold
  [
    repeat 30 [layout-spring users links 0.2 5 2]
  ]
end

to-report limit-magnitude [number limit]
  if number > limit [ report limit ]
  if number < (- limit) [ report (- limit) ]
  report number
end


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;Clustering Coefficient;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
to-report global-clustering-coefficient
  let closed-triplets sum [ nw:clustering-coefficient * count my-links * (count my-links - 1) ] of users
  let triplets sum [ count my-links * (count my-links - 1) ] of users
  ifelse triplets != 0 [report closed-triplets / triplets]
  [report 0]
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Path length computations ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Procedure to calculate the average-path-length (apl) in the network. If the network is not
; connected, we return `infinity` since apl doesn't really mean anything in a non-connected network.
to-report find-average-path-length

  let apl 0

  ; calculate all the path-lengths for each node
  find-path-lengths

  let num-connected-pairs sum [length remove infinity (remove 0 distance-from-other-turtles)] of turtles

  ; In a connected network on N nodes, we should have N(N-1) measurements of distances between pairs.
  ; If there were any "infinity" length paths between nodes, then the network is disconnected.
  ifelse num-connected-pairs != (count turtles * (count turtles - 1)) [
    ; This means the network is not connected, so we report infinity
    set apl infinity
  ][
    ifelse num-connected-pairs = 0 [set num-connected-pairs 1]
    [set apl (sum [sum distance-from-other-turtles] of turtles) / (num-connected-pairs)]
  ]

  report apl
end

; Implements the Floyd Warshall algorithm for All Pairs Shortest Paths
; It is a dynamic programming algorithm which builds bigger solutions
; from the solutions of smaller subproblems using memoization that
; is storing the results. It keeps finding incrementally if there is shorter
; path through the kth node. Since it iterates over all turtles through k,
; so at the end we get the shortest possible path for each i and j.
to find-path-lengths
  ; reset the distance list
  ask turtles [
    set distance-from-other-turtles []
  ]

  let i 0
  let j 0
  let k 0
  let node1 one-of turtles
  let node2 one-of turtles
  let node-count count turtles
  ; initialize the distance lists
  while [i < node-count] [
    set j 0
    while [ j < node-count ] [
      set node1 turtle i
      set node2 turtle j
      ; zero from a node to itself
      ifelse i = j [
        ask node1 [
          set distance-from-other-turtles lput 0 distance-from-other-turtles
        ]
      ][
        ; 1 from a node to it's neighbor
        ifelse [ link-neighbor? node1 ] of node2 [
          ask node1 [
            set distance-from-other-turtles lput 1 distance-from-other-turtles
          ]
        ][ ; infinite to everyone else
          ask node1 [
            set distance-from-other-turtles lput infinity distance-from-other-turtles
          ]
        ]
      ]
      set j j + 1
    ]
    set i i + 1
  ]
  set i 0
  set j 0
  let dummy 0
  while [k < node-count] [
    set i 0
    while [i < node-count] [
      set j 0
      while [j < node-count] [
        ; alternate path length through kth node
        set dummy ( (item k [distance-from-other-turtles] of turtle i) +
                    (item j [distance-from-other-turtles] of turtle k))
        ; is the alternate path shorter?
        if dummy < (item j [distance-from-other-turtles] of turtle i) [
          ask turtle i [
            set distance-from-other-turtles replace-item j distance-from-other-turtles dummy
          ]
        ]
        set j j + 1
      ]
      set i i + 1
    ]
    set k k + 1
  ]

end



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;Export-Dynamic-Data;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
to export-dynamic-data
  if ticks = 0 [
    file-open file-name
    file-print "tick,type,id1,id2,state,attitude-valence,opinion,expression-status,is-noisy-user"
    file-close

     ; ایجاد فایل nodes.csv و نوشتن سرستون‌ها
    file-open node-file-name
    file-print "id,label,state,start,end,attitude-valence,opinion,expression-status,is-noisy-user"
    file-close

    ; ایجاد فایل edges.csv و نوشتن سرستون‌ها
    file-open edge-file-name
    file-print "source,target,interaction,start,end"
    file-close
  ]
  file-open file-name
  ask users [file-print (word ticks ",node,"who",,"my-state","attitude-valence","opinion","expression-status","is-noisy-user)]
  ask links [file-print (word ticks ",link,"[who] of end1","[who] of end2","relationship-state)]
  file-close

  ; افزودن داده‌های جدید به فایل nodes.csv
  file-open node-file-name
  ask users [
    file-print (word who "," who "," my-state "," ticks "," 1000000 "," attitude-valence "," opinion "," expression-status "," is-noisy-user)
  ]
  file-close

  ; افزودن داده‌های جدید به فایل edges.csv
  file-open edge-file-name
  ask links [
    file-print (word [who] of end1 "," [who] of end2 "," relationship-state "," ticks "," 1000000 ",")
  ]
  file-close
end


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Export-Frames-csv;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
to export-frames-csv
  set node-file-name (word "E:/exports/revise/effect of noisy users presence/nodes-frame-" frame-count ".csv")
  set edge-file-name (word "E:/exports/revise/effect of noisy users presence/edges-frame-" frame-count ".csv")

  ; Creating nodes CSV file and writing headers
  file-open node-file-name
  file-print "id,label,state,start,end,attitude-valence,opinion,expression-status,is-noisy-user"
  ask turtles [
    file-print (word who "," who "," my-state "," ticks "," 1000000 "," attitude-valence "," opinion "," expression-status "," is-noisy-user)
  ]
  file-close

  ; Creating edges CSV file and writing headers
  file-open edge-file-name
  file-print "source,target,interaction,start,end"
  ask links [
    file-print (word [who] of end1 "," [who] of end2 "," relationship-state "," ticks "," 1000000)
  ]
  file-close

  set frame-count frame-count + 1
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Export-Frames-gexf;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
to export-frames-gexf
  set net-file-name (word "E:/exports/revise/effect of noisy users presence/" frame-count ".gexf")

  ; ذخیره شبکه به فرمت GEXF
  nw:save-gexf net-file-name

  ; افزایش شمارنده فریم
  set frame-count frame-count + 1
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;Export;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
to export
  set date-time (remove "-" remove "." remove ":" remove " " date-and-time)
  ;set file-name (word date-time)
  set file-name (word date-time "-" state "-")
  nw:save-gexf (word "E:/exports/revise/effect of noisy users presence/" file-name "gexf.gexf")
  nw:save-graphml (word "E:/exports/revise/effect of noisy users presence/" file-name "graphml.graphml")
  export-world (word "E:/exports/revise/effect of noisy users presence/" file-name "world.csv")
  ;export-interface (word "E:/exports/" file-name "interface.png")
  export-all-plots (word "E:/exports/revise/effect of noisy users presence/" file-name "plots.csv")
  ;export-view (word "E:/Hani/PhD/First-Article/exports/" file-name "view.png")
end;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;Export World;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
to export-worlds
  ;set date-time (remove "-" remove "." remove ":" remove " " date-and-time)
  set date-time (remove "-" remove "." remove ":" remove " " date-and-time)
  set file-name (word date-time "-" state "-")
  export-world (word "E:/exports/revise/effect of noisy users presence/" file-name "world.csv")
  nw:save-gexf (word "E:/exports/revise/effect of noisy users presence/" file-name "gexf.gexf")
  export-all-plots (word "E:/exports/revise/effect of noisy users presence/" file-name "plots.csv")
  export-interface (word "E:/exports/revise/effect of noisy users presence/" file-name "interface.png")
  nw:save-graphml (word "E:/exports/revise/effect of noisy users presence/" file-name "graphml.graphml")
end